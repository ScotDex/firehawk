package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"sync"
	"time"

	"github.com/bwmarrin/discordgo"
)

// redisqURL is the endpoint for the EVE-KILL real-time data feed.
const redisqURL = "https://eve-kill.com/redisq?queueID=firehawkv1"

// AutoGenerated is the struct for parsing the killmail JSON response from the data feed.
type AutoGenerated struct {
	Package struct {
		KillID   int `json:"killID"`
		Killmail struct {
			KillmailID    int       `json:"killmail_id"`
			KillmailTime  time.Time `json:"killmail_time"`
			SolarSystemID int       `json:"solar_system_id"`
			Victim        struct {
				ShipTypeID    int `json:"ship_type_id"`
				CharacterID   int `json:"character_id"`
				CorporationID int `json:"corporation_id"`
				AllianceID    int `json:"alliance_id"`
				FactionID     int `json:"faction_id"`
				DamageTaken   int `json:"damage_taken"`
				Position      struct {
					X float64 `json:"x"`
					Y float64 `json:"y"`
					Z float64 `json:"z"`
				} `json:"position"`
			} `json:"victim"`
			Attackers []struct {
				ShipTypeID     int     `json:"ship_type_id"`
				CharacterID    int     `json:"character_id"`
				CorporationID  int     `json:"corporation_id"`
				AllianceID     int     `json:"alliance_id"`
				FactionID      int     `json:"faction_id"`
				DamageDone     int     `json:"damage_done"`
				FinalBlow      bool    `json:"final_blow"`
				SecurityStatus float64 `json:"security_status"`
				WeaponTypeID   int     `json:"weapon_type_id"`
			} `json:"attackers"`
		} `json:"killmail"`
		Zkb struct {
			LocationID     int           `json:"locationID"`
			Hash           string        `json:"hash"`
			FittedValue    float64       `json:"fittedValue"`
			DroppedValue   float64       `json:"droppedValue"`
			DestroyedValue float64       `json:"destroyedValue"`
			TotalValue     float64       `json:"totalValue"`
			Points         int           `json:"points"`
			Npc            bool          `json:"npc"`
			Solo           bool          `json:"solo"`
			Awox           bool          `json:"awox"`
			Href           string        `json:"href"`
			CreatedAt      time.Time     `json:"createdAt"`
			Labels         []interface{} `json:"labels"`
		} `json:"zkb"`
	} `json:"package"`
}

// buildKillmailURL constructs the public URL for a given killmail ID.
func buildKillmailURL(killID int) string {
	return fmt.Sprintf("https://eve-kill.com/kill/%d", killID)
}

// formatISKHuman formats a float64 into a human-readable string (e.g., 1.23B, 45.6M).
func formatISKHuman(value float64) string {
	if value >= 1_000_000_000_000 { // Trillions
		return fmt.Sprintf("%.2fT ISK", value/1_000_000_000_000)
	} else if value >= 1_000_000_000 { // Billions
		return fmt.Sprintf("%.2fB ISK", value/1_000_000_000)
	} else if value >= 1_000_000 { // Millions
		return fmt.Sprintf("%.2fM ISK", value/1_000_000)
	} else if value >= 1_000 { // Thousands
		return fmt.Sprintf("%.2fK ISK", value/1_000)
	}
	return fmt.Sprintf("%.2f ISK", value)
}

// killmailPoller is the main background process that fetches, enriches, and posts killmails.
func killmailPoller(s *discordgo.Session, channelID string) {
	client := &http.Client{
		Timeout: 90 * time.Second,
	}
	log.Println("Waiting for killmails...")

	for {
		// --- 1. Fetch data from the stream ---
		resp, err := client.Get(redisqURL)
		if err != nil {
			log.Println("Error fetching killmail:", err)
			time.Sleep(5 * time.Second)
			continue
		}
		body, err := io.ReadAll(resp.Body)
		resp.Body.Close()
		if err != nil {
			log.Println("Error reading response body:", err)
			time.Sleep(5 * time.Second)
			continue
		}

		// --- 2. Parse the JSON response ---
		if string(body) == "{\"package\":null}" {
			time.Sleep(2 * time.Second) // Empty queue, wait before trying again.
			continue
		}
		var killmailData AutoGenerated
		err = json.Unmarshal(body, &killmailData)
		if err != nil {
			log.Println("Error unmarshaling JSON:", err)
			time.Sleep(5 * time.Second)
			continue
		}

		// --- 3. Filter out old killmails (currently commented out for testing) ---
		killTime := killmailData.Package.Killmail.KillmailTime
		if time.Since(killTime) > 5*time.Minute {
			log.Printf("Stale killmail (ID %d) received, skipping...\n", killmailData.Package.KillID)
			continue
		}

		log.Printf("New killmail received: ID %d in system %d\n", killmailData.Package.KillID, killmailData.Package.Killmail.SolarSystemID)

		pkg := killmailData.Package
		killID := pkg.KillID
		if killID > 0 {
			// --- 4. Extract key information ---
			victim := pkg.Killmail.Victim
			attackers := pkg.Killmail.Attackers
			var finalBlowAttacker struct {
				CharacterID   int
				CorporationID int
				ShipTypeID    int
			}
			for _, attacker := range attackers {
				if attacker.FinalBlow {
					finalBlowAttacker.CharacterID = attacker.CharacterID
					finalBlowAttacker.CorporationID = attacker.CorporationID
					finalBlowAttacker.ShipTypeID = attacker.ShipTypeID
					break
				}
			}

			// --- 5. Enrich the data by fetching names for IDs ---
			var victimName, victimCorp, victimShip, finalBlowName, finalBlowCorp, finalBlowShip, systemName string
			var wg sync.WaitGroup
			wg.Add(7)
			go func() { defer wg.Done(); victimName = esiClient.GetCharacterName(victim.CharacterID) }()
			go func() { defer wg.Done(); victimCorp = esiClient.GetCorporationName(victim.CorporationID) }()
			go func() { defer wg.Done(); victimShip = esiClient.GetShipName(victim.ShipTypeID) }()
			go func() { defer wg.Done(); finalBlowName = esiClient.GetCharacterName(finalBlowAttacker.CharacterID) }()
			go func() { defer wg.Done(); finalBlowCorp = esiClient.GetCorporationName(finalBlowAttacker.CorporationID) }()
			go func() { defer wg.Done(); finalBlowShip = esiClient.GetShipName(finalBlowAttacker.ShipTypeID) }()
			go func() { defer wg.Done(); systemName = esiClient.GetSystemName(pkg.Killmail.SolarSystemID) }()
			wg.Wait() // Wait for all enrichment goroutines to finish.

			// --- 6. Build and send the final Discord embed ---
			url := buildKillmailURL(killID)
			totalValueFormatted := formatISKHuman(pkg.Zkb.TotalValue)

			embed := &discordgo.MessageEmbed{
				Title:     fmt.Sprintf("%s destroyed in %s", victimShip, systemName),
				URL:       url,
				Color:     0xBF2A2A,
				Timestamp: pkg.Killmail.KillmailTime.Format(time.RFC3339),
				Thumbnail: &discordgo.MessageEmbedThumbnail{
					URL: fmt.Sprintf("https://images.evetech.net/types/%d/render?size=128", victim.ShipTypeID),
				},
				Fields: []*discordgo.MessageEmbedField{
					{
						Name:   "Victim",
						Value:  fmt.Sprintf("**%s**\n%s", victimName, victimCorp),
						Inline: true,
					},
					{
						Name:   fmt.Sprintf("Final Blow (%d Attackers)", len(attackers)),
						Value:  fmt.Sprintf("**%s**\n%s (%s)", finalBlowName, finalBlowCorp, finalBlowShip),
						Inline: true,
					},
					{
						Name:  "Total Value",
						Value: totalValueFormatted,
					},
				},
				Footer: &discordgo.MessageEmbedFooter{
					Text: "Powered by Firehawk",
				},
			}
			_, err := s.ChannelMessageSendEmbed(channelID, embed)
			if err != nil {
				log.Printf("Error sending enriched embed to Discord: %v", err)
			} else {
				log.Printf("Successfully posted enriched embed for kill %d.", killID)
			}
		}
		// Slight delay to prevent busy-looping if the stream ever sends data too fast.
		time.Sleep(1 * time.Second)
	}
}
